<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8" />
      <title>notes-iso-dia</title>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX","output/HTML-CSS"],
    extensions: [],
    TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
    },
    showMathMenu: false
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
</script>
      <style>
.conflict-resolved {
  background: rgba(255, 255, 255, 0.07);
}
.conflict-ours {
  background: rgba(23, 202, 101, 0.4);
}
.conflict-ours.cursor-line {
  background: rgba(23, 202, 101, 0.3);
}
.conflict-theirs {
  background: rgba(0, 152, 255, 0.4);
}
.conflict-theirs.cursor-line {
  background: rgba(0, 152, 255, 0.3);
}
.conflict-base {
  background: rgba(255, 170, 44, 0.4);
}
.conflict-base.cursor-line {
  background: rgba(255, 170, 44, 0.3);
}
.conflict-dirty {
  background: rgba(245, 225, 29, 0.4);
}
.conflict-dirty.cursor-line {
  background: rgba(245, 225, 29, 0.3);
}

.spell-check-misspelling .region {
  border-bottom: 2px dotted rgba(255, 51, 51, 0.75);
}
.spell-check-corrections {
  width: 25em !important;
}

pre.editor-colors {
  background-color: #1d1f21;
  color: #c5c8c6;
}
pre.editor-colors .wrap-guide {
  background-color: #676a6c;
}
pre.editor-colors .indent-guide {
  color: #676a6c;
}
pre.editor-colors .invisible-character {
  color: #676a6c;
}
pre.editor-colors .gutter {
  background-color: #1d1f21;
  color: #969896;
}
pre.editor-colors .gutter .line-number {
  padding: 0 0.25em 0 0.5em;
  -webkit-font-smoothing: antialiased;
}
pre.editor-colors .gutter .line-number.cursor-line {
  background-color: #373b41;
  color: #c5c8c6;
}
pre.editor-colors .gutter .line-number.cursor-line-no-selection {
  color: #c5c8c6;
}
pre.editor-colors .gutter .line-number.folded,
pre.editor-colors .gutter .line-number:after,
pre.editor-colors .fold-marker:after {
  color: #969896;
}
pre.editor-colors .invisible {
  color: #c5c8c6;
}
pre.editor-colors .cursor {
  color: #ffffff;
}
pre.editor-colors .selection .region {
  background-color: #373b41;
}
pre.editor-colors .bracket-matcher .region {
  border-color: #969896;
}
.syntax--comment {
  color: #969896;
}
.syntax--comment .syntax--markup.syntax--link {
  color: #969896;
}
.syntax--entity.syntax--name.syntax--type {
  color: #f0c674;
}
.syntax--entity.syntax--other.syntax--inherited-class {
  color: #b5bd68;
}
.syntax--keyword {
  color: #b294bb;
}
.syntax--keyword.syntax--control {
  color: #b294bb;
}
.syntax--keyword.syntax--operator {
  color: #c5c8c6;
}
.syntax--keyword.syntax--other.syntax--special-method {
  color: #81a2be;
}
.syntax--keyword.syntax--other.syntax--unit {
  color: #de935f;
}
.syntax--storage {
  color: #b294bb;
}
.syntax--constant {
  color: #de935f;
}
.syntax--constant.syntax--character.syntax--escape {
  color: #8abeb7;
}
.syntax--constant.syntax--numeric {
  color: #de935f;
}
.syntax--constant.syntax--other.syntax--color {
  color: #8abeb7;
}
.syntax--constant.syntax--other.syntax--symbol {
  color: #b5bd68;
}
.syntax--variable {
  color: #cc6666;
}
.syntax--variable.syntax--interpolation {
  color: #a3685a;
}
.syntax--variable.syntax--parameter.syntax--function {
  color: #c5c8c6;
}
.syntax--invalid.syntax--illegal {
  background-color: #cc6666;
  color: #1d1f21;
}
.syntax--string {
  color: #b5bd68;
}
.syntax--string.syntax--regexp {
  color: #8abeb7;
}
.syntax--string.syntax--regexp .syntax--source.syntax--ruby.syntax--embedded {
  color: #f0c674;
}
.syntax--string.syntax--other.syntax--link {
  color: #cc6666;
}
.syntax--punctuation.syntax--definition.syntax--parameters,
.syntax--punctuation.syntax--definition.syntax--array {
  color: #c5c8c6;
}
.syntax--punctuation.syntax--definition.syntax--heading,
.syntax--punctuation.syntax--definition.syntax--identity {
  color: #81a2be;
}
.syntax--punctuation.syntax--definition.syntax--bold {
  color: #f0c674;
  font-weight: bold;
}
.syntax--punctuation.syntax--definition.syntax--italic {
  color: #b294bb;
  font-style: italic;
}
.syntax--punctuation.syntax--section.syntax--embedded {
  color: #a3685a;
}
.syntax--punctuation.syntax--section.syntax--method,
.syntax--punctuation.syntax--section.syntax--class,
.syntax--punctuation.syntax--section.syntax--inner-class {
  color: #c5c8c6;
}
.syntax--support.syntax--class {
  color: #f0c674;
}
.syntax--support.syntax--function {
  color: #8abeb7;
}
.syntax--support.syntax--function.syntax--any-method {
  color: #81a2be;
}
.syntax--entity.syntax--name.syntax--function {
  color: #81a2be;
}
.syntax--entity.syntax--name.syntax--class,
.syntax--entity.syntax--name.syntax--type.syntax--class {
  color: #f0c674;
}
.syntax--entity.syntax--name.syntax--section {
  color: #81a2be;
}
.syntax--entity.syntax--name.syntax--tag {
  color: #cc6666;
}
.syntax--entity.syntax--other.syntax--attribute-name {
  color: #de935f;
}
.syntax--entity.syntax--other.syntax--attribute-name.syntax--id {
  color: #81a2be;
}
.syntax--meta.syntax--class {
  color: #f0c674;
}
.syntax--meta.syntax--class.syntax--body {
  color: #c5c8c6;
}
.syntax--meta.syntax--link {
  color: #de935f;
}
.syntax--meta.syntax--method-call,
.syntax--meta.syntax--method {
  color: #c5c8c6;
}
.syntax--meta.syntax--require {
  color: #81a2be;
}
.syntax--meta.syntax--selector {
  color: #b294bb;
}
.syntax--meta.syntax--separator {
  background-color: #373b41;
  color: #c5c8c6;
}
.syntax--meta.syntax--tag {
  color: #c5c8c6;
}
.syntax--none {
  color: #c5c8c6;
}
.syntax--markup.syntax--bold {
  color: #de935f;
  font-weight: bold;
}
.syntax--markup.syntax--changed {
  color: #b294bb;
}
.syntax--markup.syntax--deleted {
  color: #cc6666;
}
.syntax--markup.syntax--italic {
  color: #b294bb;
  font-style: italic;
}
.syntax--markup.syntax--heading {
  color: #cc6666;
}
.syntax--markup.syntax--heading .syntax--punctuation.syntax--definition.syntax--heading {
  color: #81a2be;
}
.syntax--markup.syntax--link {
  color: #81a2be;
}
.syntax--markup.syntax--inserted {
  color: #b5bd68;
}
.syntax--markup.syntax--quote {
  color: #de935f;
}
.syntax--markup.syntax--raw {
  color: #b5bd68;
}
.syntax--source.syntax--gfm .syntax--markup {
  -webkit-font-smoothing: auto;
}
.syntax--source.syntax--gfm .syntax--link .syntax--entity {
  color: #8abeb7;
}
.syntax--source.syntax--cs .syntax--keyword.syntax--operator {
  color: #b294bb;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--string.syntax--quoted.syntax--json {
  color: #cc6666;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation.syntax--string {
  color: #cc6666;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--value.syntax--json > .syntax--string.syntax--quoted.syntax--json > .syntax--punctuation {
  color: #b5bd68;
}
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--dictionary.syntax--json > .syntax--constant.syntax--language.syntax--json,
.syntax--source.syntax--json .syntax--meta.syntax--structure.syntax--array.syntax--json > .syntax--constant.syntax--language.syntax--json {
  color: #8abeb7;
}
</style>
  </head>
  <body class='markdown-preview'><h2>Model Theory Reference</h2>
<span class="math"><script type="math/tex; mode=display">\def\bfall{\boldsymbol{\forall}}\def\bfex{\boldsymbol{\exists}}
</script></span>
<p>This is essentially a glossary of the most basic and important model theory concepts along with some elementary facts about them.</p>
<hr>
<h3>Signatures, Languages, Terms, Formulas, Sentences</h3>
<h4>Signatures</h4>
<ul>
<li>A <strong>signature</strong> <span class="math"><script type="math/tex">\sigma = (\mathbf{C}, \mathbf{F}, \mathbf{R}, \sigma')</script></span> consists of
three (possibly empty) sets <span class="math"><script type="math/tex">\mathbf{C}</script></span>, <span class="math"><script type="math/tex">\mathbf{F}</script></span>, and <span class="math"><script type="math/tex">\mathbf{R}</script></span> of <em>constant</em>, <em>function</em>, and <em>relation</em> symbols (resp.), along with a function
<span class="math"><script type="math/tex">\sigma': \mathbf{C} + \mathbf {F} + \mathbf{R} \to \mathbb N</script></span> that assigns an <em>arity</em> to each symbol.</li>
</ul>
<hr>
<h4>Languages</h4>
<ul>
<li>
<p>The <strong>language</strong> <span class="math"><script type="math/tex">L = L(\sigma)</script></span> of signature <span class="math"><script type="math/tex">\sigma</script></span> is a certain collection of strings of symbols from the following <strong>alphabet</strong> of symbols:</p>
<ul>
<li><strong>logical symbols</strong>
<ul>
<li><em>logical connectives</em>: <span class="math"><script type="math/tex">\neg</script></span> ,  <span class="math"><script type="math/tex">\wedge</script></span> , <span class="math"><script type="math/tex">\vee</script></span> (resp. “negation,” “conjunction,” "disjunction),</li>
<li><em>existential quantifier:</em> <span class="math"><script type="math/tex">\exists</script></span></li>
<li><em>equality</em>: <span class="math"><script type="math/tex">=</script></span></li>
</ul>
</li>
<li><strong>variables</strong> (countably many)</li>
<li><strong>non-logical symbols</strong> from <span class="math"><script type="math/tex">\sigma</script></span> (the constant, function, and relation symbols)</li>
<li><strong>parentheses</strong> ( and )</li>
</ul>
<p>To specify which strings of symbols belong to <span class="math"><script type="math/tex">L</script></span>, we need to define the <em>terms</em> and <em>formulas</em> of <span class="math"><script type="math/tex">\sigma</script></span>. Eventually, we will define <span class="math"><script type="math/tex">L</script></span> to be <em>the set of all <span class="math"><script type="math/tex">\sigma</script></span>-formulas.</em></p>
</li>
</ul>
<hr>
<h4>Terms</h4>
<p>The <strong>terms</strong> of signature <span class="math"><script type="math/tex">\sigma</script></span> (aka <span class="math"><script type="math/tex">\sigma</script></span>-<strong>terms</strong>) are defined recursively as follows:</p>
<ul>
<li>All variables are terms.</li>
<li>All constant symbols are terms.</li>
<li>If <span class="math"><script type="math/tex">t_0, \dots, t_{n-1}</script></span> are terms and <span class="math"><script type="math/tex">f\in \mathbf F</script></span> with <span class="math"><script type="math/tex">\sigma'(f) = n</script></span>,
then <span class="math"><script type="math/tex">f(t_0,\dots, t_{n-1})</script></span> is a term.</li>
<li><span class="math"><script type="math/tex">t</script></span> is a terms if it can be obtained in finitely many steps from some combination of the three items above.</li>
</ul>
<hr>
<h4>Formulas</h4>
<p>The <strong>formulas</strong> of <span class="math"><script type="math/tex">\sigma</script></span> (aka <span class="math"><script type="math/tex">\sigma</script></span>-formulas) are defined recursively as follows:</p>
<ul>
<li>If <span class="math"><script type="math/tex">t_1</script></span> and <span class="math"><script type="math/tex">t_2</script></span> are <span class="math"><script type="math/tex">\sigma</script></span>-terms, then <span class="math"><script type="math/tex">t_1 = t_2</script></span> is a <span class="math"><script type="math/tex">\sigma</script></span>-formula.</li>
<li>If <span class="math"><script type="math/tex">t_0,\dots, t_{n-1}</script></span> are <span class="math"><script type="math/tex">\sigma</script></span>-terms and <span class="math"><script type="math/tex">R \in \mathbf R</script></span> with <span class="math"><script type="math/tex">\sigma'(R)=n</script></span>, then <span class="math"><script type="math/tex">R(t_0,\dots, t_{n-1})</script></span> is a <span class="math"><script type="math/tex">\sigma</script></span>-formula.</li>
<li>If <span class="math"><script type="math/tex">\varphi</script></span> and <span class="math"><script type="math/tex">\psi</script></span> are <span class="math"><script type="math/tex">\sigma</script></span>-formulas and <span class="math"><script type="math/tex">x</script></span> is a variable, then
<span class="math"><script type="math/tex">\neg \varphi</script></span>, <span class="math"><script type="math/tex">\varphi \wedge \psi</script></span>, and <span class="math"><script type="math/tex">\exists x \varphi</script></span> are formulas too.</li>
<li><span class="math"><script type="math/tex">\varphi</script></span> is a fornıula if it can be obtained in finitely many steps from some combination of the three items above.</li>
</ul>
<p>Finally, we can define</p>
<ul>
<li>The <strong>language</strong> <span class="math"><script type="math/tex">L = L(\sigma)</script></span> is the set of all <span class="math"><script type="math/tex">\sigma</script></span>-formulas.</li>
</ul>
<hr>
<h4>Sentences</h4>
<ul>
<li>A term <span class="math"><script type="math/tex">t</script></span> is said to be <strong>constant</strong> (or <strong>closed</strong>) if it contains no variables.</li>
<li>A formula <span class="math"><script type="math/tex">\varphi</script></span> is called a <strong>sentence</strong> (or <strong>closed formula</strong>) if it contains <em>no <strong>free</strong> variables</em>; that is, all variables appearing in <span class="math"><script type="math/tex">\varphi</script></span> are bound;</li>
<li><span class="math"><script type="math/tex">L_0 :=</script></span> all sentences in the language <span class="math"><script type="math/tex">L</script></span> (aka “<span class="math"><script type="math/tex">L</script></span>-sentences”);</li>
<li>An <strong>atomic</strong> <span class="math"><script type="math/tex">L</script></span>-formula has one of the following two forms:
<ul>
<li><span class="math"><script type="math/tex">s = t</script></span>, where <span class="math"><script type="math/tex">s</script></span> and <span class="math"><script type="math/tex">t</script></span> are <span class="math"><script type="math/tex">L</script></span>-terms;</li>
<li><span class="math"><script type="math/tex">R(t_0, \dots, t_{n-1})</script></span>, where <span class="math"><script type="math/tex">R</script></span> is an relation symbol in <span class="math"><script type="math/tex">L</script></span> and <span class="math"><script type="math/tex">t_i</script></span> are <span class="math"><script type="math/tex">L</script></span>-terms;</li>
</ul>
</li>
<li><span class="math"><script type="math/tex">\mathbf{at}_L</script></span> (or just <span class="math"><script type="math/tex">\mathbf{at}</script></span> when the context makes <span class="math"><script type="math/tex">L</script></span> clear) is the class of all atomic <span class="math"><script type="math/tex">L</script></span>-formulas.</li>
<li>An <strong>atomic</strong> <span class="math"><script type="math/tex">L</script></span>-sentence is either an equation of constant terms or a relational sentence, <span class="math"><script type="math/tex">R(t_0, \dots, t_{n-1})</script></span>, where all <span class="math"><script type="math/tex">t_i</script></span> are closed terms;</li>
<li>A <strong>literal</strong> <span class="math"><script type="math/tex">L</script></span>-formula (or, <span class="math"><script type="math/tex">L</script></span>-<strong>literal</strong>) is an atomic or negated atomic <span class="math"><script type="math/tex">L</script></span>-formula;</li>
<li><span class="math"><script type="math/tex">\mathbf{lt}_L:=</script></span> the set of all <span class="math"><script type="math/tex">L</script></span>-<strong>literals</strong>; that is, <span class="math"><script type="math/tex">\mathbf{at}_L \cup \{\neg \varphi : \varphi \in \mathbf{at}_L\}</script></span>;</li>
<li><span class="math"><script type="math/tex">\mathbf{cl}_L:=</script></span> the set of all <strong>closed</strong> <span class="math"><script type="math/tex">L</script></span>-<strong>literals</strong> (literal <span class="math"><script type="math/tex">L</script></span>-sentences; that is, literals without free variables).</li>
</ul>
<p><strong>Remarks.</strong></p>
<ul>
<li>Every constant symbol is a constant term.</li>
<li>An atomic sentence contains no variables at all.</li>
<li><em>Languages without constant symbols have no atomic sentences.</em></li>
<li>Every language comes equipped with a countable supply of variables, so the cardinality of <span class="math"><script type="math/tex">L</script></span> is <span class="math"><script type="math/tex">|L| = \max \{\aleph_0, |\mathbf C \cup \mathbf F \cup \mathbf R|\}</script></span>.</li>
</ul>
<hr>
<h4>Boolean comibinations and quantifier-free formulas</h4>
<p>Let <span class="math"><script type="math/tex">\Sigma</script></span> be a set of formulas.</p>
<ul>
<li>
<p>A <strong>boolean combination</strong> of formulas from <span class="math"><script type="math/tex">\Sigma</script></span> is obtained by connecting formulas from <span class="math"><script type="math/tex">\Sigma</script></span> using only the logical connectives; i.e., only <span class="math"><script type="math/tex">\vee</script></span>, <span class="math"><script type="math/tex">\wedge</script></span>, <span class="math"><script type="math/tex">\neg</script></span>.</p>
</li>
<li>
<p>A <strong>positive boolean combination</strong> of formulas from <span class="math"><script type="math/tex">\Sigma</script></span> is obtained by connecting formulas from <span class="math"><script type="math/tex">\Sigma</script></span> with only <span class="math"><script type="math/tex">\wedge</script></span> and <span class="math"><script type="math/tex">\vee</script></span>.</p>
</li>
<li>
<p>The <strong>boolean closure</strong> of <span class="math"><script type="math/tex">\Sigma</script></span> is the set <span class="math"><script type="math/tex">\tilde{\Sigma}</script></span> of all boolean combinations of formulas from <span class="math"><script type="math/tex">\Sigma</script></span>.</p>
</li>
<li>
<p>A <strong>positive</strong> formula is obtained from atomic formulas using
only <span class="math"><script type="math/tex">\wedge</script></span>, <span class="math"><script type="math/tex">\vee</script></span>, <span class="math"><script type="math/tex">\exists</script></span>, <span class="math"><script type="math/tex">\forall</script></span>.<br>
The class of all positive formulas (of all possible languages) is denoted by <span class="math"><script type="math/tex">\boldsymbol{+}</script></span>.</p>
</li>
<li>
<p>A <strong>negative</strong> formula is a negated positive formula. The class of all such
is denoted by <span class="math"><script type="math/tex">\boldsymbol{-}</script></span>.</p>
</li>
<li>
<p>A <strong>quantifier-free</strong> formula is one that contains no quantifiers; we
assume <span class="math"><script type="math/tex">\top</script></span> and <span class="math"><script type="math/tex">\perp</script></span> are quantifier-free.<br>
The class of all quantilier-free formulas (of arbitrary signature) is denoted by <span class="math"><script type="math/tex">\mathbf{qf}</script></span>.</p>
</li>
</ul>
<p><strong>Remarks.</strong></p>
<ul>
<li>In the definition of boolean combinations, we could allow <span class="math"><script type="math/tex">\to</script></span> and <span class="math"><script type="math/tex">\leftrightarrow</script></span>; we could do without <span class="math"><script type="math/tex">\vee</script></span>.</li>
<li><span class="math"><script type="math/tex">\mathbf{qf}</script></span> is the class of all boolean combinations of atomic formulas.</li>
</ul>
<hr>
<h4>Expansion by Constants, Validity, Truth</h4>
<p>Fix a signature <span class="math"><script type="math/tex">\sigma = (\mathbf{C}, \mathbf{F}, \mathbf{R}, \sigma')</script></span> and a language <span class="math"><script type="math/tex">L = L(\sigma)</script></span> (i.e., <span class="math"><script type="math/tex">L</script></span> is a language of signature <span class="math"><script type="math/tex">\sigma</script></span>). Let <span class="math"><script type="math/tex">\mathcal M = \langle M, \dots\rangle</script></span> and <span class="math"><script type="math/tex">\mathcal N = \langle N, \dots\rangle</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures, let <span class="math"><script type="math/tex">\mathbf x = (x_0, x_{1}, \dots)</script></span> be a tuple of variables, and let <span class="math"><script type="math/tex">\varphi = \varphi(\mathbf x)</script></span> be an <span class="math"><script type="math/tex">L</script></span>-formula.</p>
<h5>Expansion by Constants</h5>
<ul>
<li>A <strong>new constant</strong> (<strong>symbol</strong>) for <span class="math"><script type="math/tex">L</script></span> is any symbol not occuring in the alphabet of <span class="math"><script type="math/tex">L</script></span>.</li>
<li><span class="math"><script type="math/tex">L(C)</script></span> is the <strong>expansion</strong> of <span class="math"><script type="math/tex">L</script></span> by new constant symbols <span class="math"><script type="math/tex">C</script></span>, and is defined to be the (uniquely determined) language of signature <span class="math"><script type="math/tex">(\mathbf C \cup C, \mathbf F, \mathbf R, \sigma')</script></span>.</li>
<li><span class="math"><script type="math/tex">\Delta(C)</script></span> is the <strong>expansion</strong> of <span class="math"><script type="math/tex">\Delta</script></span> by new constants symbols <span class="math"><script type="math/tex">C</script></span> (not occuring in <span class="math"><script type="math/tex">\Delta</script></span>) and is defined to be the class of all the formulas obtained from formulas <span class="math"><script type="math/tex">\varphi \in \Delta</script></span> upon substituting (at will) elements from <span class="math"><script type="math/tex">C</script></span> for variables in <span class="math"><script type="math/tex">\varphi</script></span>. (“At will” indicates that <span class="math"><script type="math/tex">\Delta\subseteq \Delta(C)</script></span>.)</li>
<li><span class="math"><script type="math/tex">\mathbf{lt}_{L(M)}:=</script></span> the set of all atomic and negated atomic <span class="math"><script type="math/tex">L(M)</script></span>-formulas.</li>
<li><span class="math"><script type="math/tex">\mathbf{cl}_{L(M)}:=</script></span> the set of all atomic and negated atomic <span class="math"><script type="math/tex">L(M)</script></span>-setnences.</li>
</ul>
<h5>Validity and Truth</h5>
<ul>
<li><span class="math"><script type="math/tex">\mathcal M \vDash \varphi</script></span> means that <span class="math"><script type="math/tex">\varphi</script></span> is <strong>valid</strong> in <span class="math"><script type="math/tex">\mathcal M</script></span> which means that for every tuple <span class="math"><script type="math/tex">\mathbf a  = (a_0, a_1, \dots )</script></span> from <span class="math"><script type="math/tex">M</script></span> (that is at least as long as <span class="math"><script type="math/tex">\mathbf x</script></span>) the <span class="math"><script type="math/tex">L</script></span>-sentence <span class="math"><script type="math/tex">\varphi(\mathbf a)</script></span> is <em>true in <span class="math"><script type="math/tex">\mathcal M</script></span></em>.</li>
</ul>
<p><em>What exactly do we mean by "<span class="math"><script type="math/tex">\varphi(\mathbf a)</script></span> is true in <span class="math"><script type="math/tex">\mathcal M</script></span>?"</em></p>
<p>Intuitively, for each <span class="math"><script type="math/tex">i</script></span> we subsitute the element <span class="math"><script type="math/tex">a_i</script></span> for the variable <span class="math"><script type="math/tex">x_i</script></span> in the formula <span class="math"><script type="math/tex">\varphi(\mathbf x)</script></span>, which yields a sentence <span class="math"><script type="math/tex">\varphi(\mathbf a)</script></span> that is “decidable” in <span class="math"><script type="math/tex">\mathcal M</script></span>. That is, there is a finite procedure by which we can determine whether or not <span class="math"><script type="math/tex">\varphi(\mathbf a)</script></span> holds (or is “true”) in <span class="math"><script type="math/tex">\mathcal M</script></span>.</p>
<p>Formally, however, we may follow a more careful procedure for judging the truth of a given formula <span class="math"><script type="math/tex">\varphi</script></span> in a given structure <span class="math"><script type="math/tex">\mathcal M = \langle M, \dots\rangle</script></span>.  This is the simple matter of how syntactically to denote interpretation of variables.  But as Hodges puts it, this is “one of the more irksome parts of model theory.”</p>
<p>The issue is explained clearly in Section 1.4 of Hodges, “Model Theory,” so we defer to that presentation:</p>
<ul>
<li>
<p>The conventions for interpreting variables are one of the more irksome parts
of model theory. We can avoid them, at a price. Instead of interpreting a
variable as a name of the element <span class="math"><script type="math/tex">b</script></span>, we can add a new constant for <span class="math"><script type="math/tex">b</script></span> to
the signature. The price we pay is that the language changes every time another
element is named. When constants are added to a signature, the new
constants and the elements they name are called parameters.</p>
<p>Suppose for example that <span class="math"><script type="math/tex">\mathcal A</script></span> is an <span class="math"><script type="math/tex">L</script></span>-structure, <span class="math"><script type="math/tex">\mathbf a</script></span> is a sequence of elements of <span class="math"><script type="math/tex">\mathcal A</script></span>, and we want to name the elements in <span class="math"><script type="math/tex">\mathbf a</script></span>. Then we choose a sequence <span class="math"><script type="math/tex">\mathbf c</script></span> of distinct new constant symbols, of the same length as <span class="math"><script type="math/tex">\mathbf a</script></span>, and we form the signature <span class="math"><script type="math/tex">L(\mathbf c)</script></span> by adding the constants <span class="math"><script type="math/tex">\mathbf c</script></span> to <span class="math"><script type="math/tex">L</script></span>. Then <span class="math"><script type="math/tex">(\mathcal A, \mathbf a)</script></span> is an <span class="math"><script type="math/tex">L(\mathbf c)</script></span>-structure, and each element <span class="math"><script type="math/tex">a_i</script></span> is <span class="math"><script type="math/tex">c_i^{(\mathcal A, \mathbf a)}</script></span>.</p>
<p>Likewise if <span class="math"><script type="math/tex">\mathcal B</script></span> is another <span class="math"><script type="math/tex">L</script></span>-structure and <span class="math"><script type="math/tex">\mathbf b</script></span> a sequence of elements of <span class="math"><script type="math/tex">\mathcal B</script></span> of the same length as <span class="math"><script type="math/tex">\mathbf c</script></span>, then there is an <span class="math"><script type="math/tex">L(\mathbf c)</script></span>-structure <span class="math"><script type="math/tex">(\mathcal B, \mathbf b)</script></span> in which these same constants <span class="math"><script type="math/tex">c_i</script></span> name the elements of <span class="math"><script type="math/tex">\mathbf b</script></span>. The next lemma is about this situation. It comes straight out of the definitions, and it is often used silently.</p>
<p><strong>Lemma</strong> [1.4.1. Hodges] Let <span class="math"><script type="math/tex">\mathcal A</script></span>, <span class="math"><script type="math/tex">\mathcal B</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures and suppose <span class="math"><script type="math/tex">(\mathcal A, \mathbf a)</script></span>, <span class="math"><script type="math/tex">(\mathcal B, \mathbf b)</script></span> are <span class="math"><script type="math/tex">L(\mathbf c)</script></span>-structures. Then a homomorphism <span class="math"><script type="math/tex">f \colon (\mathcal A, \mathbf a) \to (\mathcal B, \mathbf b)</script></span> is the same thing as a homomorphism <span class="math"><script type="math/tex">f \colon \mathcal A \to \mathcal B</script></span> such that <span class="math"><script type="math/tex">f[\mathbf a] = \mathbf b</script></span>.</p>
</li>
</ul>
<p>In the situation above, if <span class="math"><script type="math/tex">t(\mathbf x)</script></span> is a term of <span class="math"><script type="math/tex">L</script></span>, then <span class="math"><script type="math/tex">t^{\mathcal A}(\mathbf a)</script></span> and <span class="math"><script type="math/tex">t(\mathbf c)^{(\mathcal A, \mathbf a)}</script></span> are
the same element; and if <span class="math"><script type="math/tex">\varphi(\mathbf x)</script></span> is an atomic formula then
<span class="math"><script type="math/tex">\mathcal A \vDash \varphi_{\mathbf x}(\mathbf a) \; \Leftrightarrow \;
(\mathcal A, \mathbf c) \vDash \varphi_{\mathbf x}(\mathbf c)</script></span>.</p>
<p><strong>Notation</strong> (used above) <span class="math"><script type="math/tex">f[\mathbf a]</script></span> is shorthand for <span class="math"><script type="math/tex">(f(a_0), f(a_1), \dots)</script></span> and <span class="math"><script type="math/tex">\varphi_{\mathbf x}(\mathbf a)</script></span> is shorthand for <span class="math"><script type="math/tex">[a_0/x_0, a_1/x_1, \dots]\varphi(x_0, x_1, \dots)</script></span>, the sentence obtained from <span class="math"><script type="math/tex">\varphi</script></span> upon substituting <span class="math"><script type="math/tex">a_i</script></span> for <span class="math"><script type="math/tex">x_i</script></span>, for each <span class="math"><script type="math/tex">i</script></span>.</p>
<hr>
<h3>Models, Theories, Diagrams</h3>
<p>Let <span class="math"><script type="math/tex">\varphi \in L_0</script></span>, <span class="math"><script type="math/tex">\Sigma\subseteq L_0</script></span>, and let <span class="math"><script type="math/tex">\mathcal M = \langle M, \dots\rangle</script></span> and <span class="math"><script type="math/tex">\mathcal N = \langle N, \dots\rangle</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures. Let <span class="math"><script type="math/tex">\Delta</script></span> be an arbitrary class of formulas (not necessarily from <span class="math"><script type="math/tex">L</script></span>).</p>
<h4>Models</h4>
<ul>
<li>If <span class="math"><script type="math/tex">M\neq \emptyset</script></span> and <span class="math"><script type="math/tex">\mathcal M \vDash \Sigma</script></span>, then <span class="math"><script type="math/tex">\mathcal M</script></span> is a <strong>model</strong> of <span class="math"><script type="math/tex">\Sigma</script></span>; we also say "<span class="math"><script type="math/tex">\mathcal M</script></span> <em>models</em> <span class="math"><script type="math/tex">\Sigma</script></span>."</li>
<li><span class="math"><script type="math/tex">\operatorname{Mod}_L \Sigma :=</script></span> the class of <span class="math"><script type="math/tex">L</script></span>-structures that model <span class="math"><script type="math/tex">\Sigma</script></span>.</li>
<li><span class="math"><script type="math/tex">\operatorname{Mod}_L \emptyset :=</script></span> the class of all nonempty <span class="math"><script type="math/tex">L</script></span>-structures.</li>
<li><span class="math"><script type="math/tex">\Sigma</script></span> <strong>entails</strong> <span class="math"><script type="math/tex">\varphi</script></span>, denoted <span class="math"><script type="math/tex">\Sigma \vdash \varphi</script></span>, if every model of <span class="math"><script type="math/tex">\Sigma</script></span> also models <span class="math"><script type="math/tex">\varphi</script></span>.</li>
<li><span class="math"><script type="math/tex">\varphi</script></span> is a <strong>logical consequence</strong> of <span class="math"><script type="math/tex">\Sigma</script></span> means <span class="math"><script type="math/tex">\Sigma</script></span> entails <span class="math"><script type="math/tex">\varphi</script></span>.</li>
<li>The <strong>deductive closure</strong> of <span class="math"><script type="math/tex">\Sigma</script></span> is the set <span class="math"><script type="math/tex">\Sigma^{\vdash} = \{\varphi \in L_0 : \Sigma \vdash \varphi\}</script></span> of logical consequences of <span class="math"><script type="math/tex">\Sigma</script></span>.</li>
<li><span class="math"><script type="math/tex">\Sigma</script></span> <strong>deductively closed</strong> if <span class="math"><script type="math/tex">\Sigma^\vdash \subseteq \Sigma</script></span>.</li>
<li><span class="math"><script type="math/tex">\Sigma_0, \Sigma_1 \subseteq L_0</script></span> are <span class="math"><script type="math/tex">\Sigma</script></span>-<strong>equivalent</strong> if <span class="math"><script type="math/tex">(\Sigma \cup \Sigma_0)^\vdash = (\Sigma \cup \Sigma_1)^\vdash</script></span>.</li>
<li><strong>logically equivalent</strong> means <span class="math"><script type="math/tex">\emptyset</script></span>-equivalent.</li>
<li>A <strong>contradiction</strong> is an <span class="math"><script type="math/tex">L</script></span>-sentence of the form <span class="math"><script type="math/tex">\varphi \wedge \neg \varphi</script></span>.</li>
<li><span class="math"><script type="math/tex">\Sigma</script></span> is <strong>consistent</strong> if <span class="math"><script type="math/tex">\Sigma^\vdash</script></span> contains no contradictions; otherwise, <span class="math"><script type="math/tex">\Sigma</script></span> is <strong>inconsistent</strong>.<br>
<strong>Remark.</strong> No model satisfies a contradiction, so the deductive closure of a contradiction is the set <span class="math"><script type="math/tex">L_0</script></span> of all <span class="math"><script type="math/tex">L</script></span>-sentences, and <span class="math"><script type="math/tex">L_0</script></span> is the only deductively closed inconsistent set of <span class="math"><script type="math/tex">L</script></span>-sentences.</li>
</ul>
<hr>
<h4>Theories</h4>
<ul>
<li>
<p>An <span class="math"><script type="math/tex">L</script></span>-<strong>theory</strong> is a <em>consistent</em> and <em>deductively closed</em> set of <span class="math"><script type="math/tex">L</script></span>-sentences.</p>
</li>
<li>
<p>The <strong>cardinality</strong> or <strong>power</strong> of an <span class="math"><script type="math/tex">L</script></span>-theory <span class="math"><script type="math/tex">T</script></span> is denoted <span class="math"><script type="math/tex">|T|</script></span> and defined to be the cardinality of <span class="math"><script type="math/tex">L</script></span>.</p>
</li>
<li>
<p><span class="math"><script type="math/tex">T_\Delta = (T \cap \Delta)^\vdash</script></span> is the <span class="math"><script type="math/tex">\Delta</script></span>-<strong>part</strong> of the <span class="math"><script type="math/tex">L</script></span>-theory <span class="math"><script type="math/tex">T</script></span> (here <span class="math"><script type="math/tex">\Delta</script></span> is an arbibtrary class of formulas).</p>
</li>
<li>
<p><span class="math"><script type="math/tex">\bfall</script></span> is the class of formulas in which <span class="math"><script type="math/tex">\exists</script></span> does not appear; <span class="math"><script type="math/tex">T_{\bfall} = (T \cap \bfall)^\vdash</script></span> is the <em>universal part</em> of <span class="math"><script type="math/tex">T</script></span>.</p>
</li>
<li>
<p><span class="math"><script type="math/tex">\operatorname{Th}_\Delta \mathcal M := \{\varphi \in L_0 : \varphi \in \Delta,\; \mathcal M \vDash \varphi\}=</script></span> all <span class="math"><script type="math/tex">L</script></span>-sentences in <span class="math"><script type="math/tex">\Delta</script></span> that are true in <span class="math"><script type="math/tex">\mathcal M</script></span>.</p>
</li>
<li>
<p><span class="math"><script type="math/tex">\operatorname{Th} \mathcal M := \operatorname{Th}_{L_0} \mathcal M =</script></span> all <span class="math"><script type="math/tex">L</script></span>-sentences that are true in <span class="math"><script type="math/tex">\mathcal M</script></span>.</p>
</li>
<li>
<p>An <span class="math"><script type="math/tex">L</script></span>-theory <span class="math"><script type="math/tex">T</script></span> is <strong>complete</strong> if for all <span class="math"><script type="math/tex">\varphi\in L_0</script></span>, either <span class="math"><script type="math/tex">\varphi \in T</script></span> or <span class="math"><script type="math/tex">\neg\varphi\in T</script></span>.<br>
<strong>Lemma 3.5.1.</strong> If <span class="math"><script type="math/tex">T</script></span> is an <span class="math"><script type="math/tex">L</script></span>-theory, the following are equivalent:</p>
<ol>
<li><span class="math"><script type="math/tex">T</script></span> is complete.</li>
<li><span class="math"><script type="math/tex">T</script></span> is a maximal <span class="math"><script type="math/tex">L</script></span>-theory.</li>
<li><span class="math"><script type="math/tex">T</script></span> is a maximal consistent set of <span class="math"><script type="math/tex">L</script></span>-sentences.</li>
<li><span class="math"><script type="math/tex">T= \operatorname{Th}\mathcal M</script></span> for all <span class="math"><script type="math/tex">\mathcal M \vDash T</script></span>.</li>
<li><span class="math"><script type="math/tex">T= \operatorname{Th}\mathcal M</script></span> for some <span class="math"><script type="math/tex">\mathcal M \vDash T</script></span>.</li>
</ol>
</li>
<li>
<p><strong>Examples.</strong></p>
<ul>
<li><span class="math"><script type="math/tex">T^\infty</script></span> is the theory of the class of all infinite models of <span class="math"><script type="math/tex">T</script></span>.</li>
<li><span class="math"><script type="math/tex">T_=</script></span> is the <strong>theory of pure identity</strong>, which is the <span class="math"><script type="math/tex">L_=</script></span>-theory of all sets (regarded as <span class="math"><script type="math/tex">L_=</script></span>-structures).</li>
</ul>
</li>
</ul>
<hr>
<h4>Diagrams</h4>
<ul>
<li>The <strong>diagram</strong> of <span class="math"><script type="math/tex">\mathcal M</script></span> is the set <span class="math"><script type="math/tex">D(\mathcal M) := \mathbf{cl}_{L(M)}</script></span> of all atomic and negated atomic <span class="math"><script type="math/tex">L(M)</script></span>-sentences;</li>
<li><span class="math"><script type="math/tex">\mathcal M \Rrightarrow_{\Delta} \mathcal N</script></span> means <span class="math"><script type="math/tex">\mathcal M \vDash \varphi</script></span> implies <span class="math"><script type="math/tex">\mathcal N \vDash \varphi</script></span> for all <span class="math"><script type="math/tex">\varphi \in \Delta \cap L_0</script></span>.</li>
<li><span class="math"><script type="math/tex">\mathcal M \Rrightarrow \mathcal N</script></span> means <span class="math"><script type="math/tex">\mathcal M \Rrightarrow_{L} \mathcal N</script></span>.</li>
<li><span class="math"><script type="math/tex">\mathcal M \equiv \mathcal N</script></span> means <span class="math"><script type="math/tex">\mathcal M \Rrightarrow \mathcal N</script></span> and <span class="math"><script type="math/tex">\mathcal M \Lleftarrow \mathcal N</script></span> hold, and this is equivalent to <span class="math"><script type="math/tex">\operatorname{Th} \mathcal M = \operatorname{Th} \mathcal N</script></span>.<br>
We call <span class="math"><script type="math/tex">\mathcal M</script></span> and <span class="math"><script type="math/tex">\mathcal N</script></span> <strong>elementarily equivalent</strong> in this case.</li>
<li><span class="math"><script type="math/tex">f \colon \mathcal M \hookrightarrow \mathcal N</script></span> means
<span class="math"><script type="math/tex">f</script></span> is an <span class="math"><script type="math/tex">L</script></span>-structure-monomorphism from <span class="math"><script type="math/tex">\mathcal M</script></span> to <span class="math"><script type="math/tex">\mathcal N</script></span>.</li>
<li><span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\Delta}{\longrightarrow} \mathcal N</script></span> means all <span class="math"><script type="math/tex">L</script></span>-formulas in <span class="math"><script type="math/tex">\Delta</script></span> are preserved by <span class="math"><script type="math/tex">f</script></span>.  That is,<br>
<span class="math"><script type="math/tex">\mathcal M \vDash \varphi(\mathbf a)</script></span> implies  <span class="math"><script type="math/tex">\mathcal N \vDash \varphi(f[\mathbf a])</script></span>, for all <span class="math"><script type="math/tex">\varphi \in \Delta\cap L</script></span> and all tuples <span class="math"><script type="math/tex">\mathbf a</script></span> from <span class="math"><script type="math/tex">M</script></span>.</li>
<li><span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span> means
<span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{L}{\longrightarrow} \mathcal N</script></span>.</li>
</ul>
<hr>
<p><strong>Facts.</strong> Let <span class="math"><script type="math/tex">\mathcal M</script></span> and <span class="math"><script type="math/tex">\mathcal N</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures and let <span class="math"><script type="math/tex">\Delta</script></span> be a set of <span class="math"><script type="math/tex">L</script></span>-formulas.</p>
<ol>
<li><span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\mathbf{at}}{\longrightarrow} \mathcal N</script></span>iff <span class="math"><script type="math/tex">f \colon \mathcal M \rightarrow \mathcal N</script></span></li>
<li><span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\Delta}{\longrightarrow} \mathcal N</script></span> iff <span class="math"><script type="math/tex">(\mathcal M, M) \Rrightarrow_{\Delta(M)} (\mathcal N, f[M])</script></span>.</li>
<li>If <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\Delta}{\longrightarrow} \mathcal N</script></span> and <span class="math"><script type="math/tex">\Delta</script></span> contains <span class="math"><script type="math/tex">\mathbf{at}</script></span> and all negations of
unnested relational atomic formulas, then
<span class="math"><script type="math/tex">f</script></span> is a strong homomorphism. (The converse is not true.)</li>
<li>If
<span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\Delta}{\longrightarrow} \mathcal N</script></span>
and <span class="math"><script type="math/tex">\Delta</script></span> is closed under negation, then <span class="math"><script type="math/tex">\mathcal M \vDash \varphi(\mathbf a)</script></span> implies <span class="math"><script type="math/tex">\mathcal N \vDash \varphi(f[\mathbf a])</script></span>, for all <span class="math"><script type="math/tex">\varphi \in \Delta</script></span> and tuples <span class="math"><script type="math/tex">\mathbf a</script></span> from <span class="math"><script type="math/tex">M</script></span>.</li>
<li><span class="math"><script type="math/tex">f \colon M \to N</script></span> is injective iff
<span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\Delta}{\longrightarrow} \mathcal N</script></span> for the set <span class="math"><script type="math/tex">\Delta = \{x \neq y\}</script></span>.</li>
<li>If <span class="math"><script type="math/tex">\Delta \subseteq L_0</script></span>, then
<span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\Delta}{\longrightarrow} \mathcal N</script></span> iff <span class="math"><script type="math/tex">\mathcal M \Rrightarrow_{\Delta} \mathcal N</script></span> and <span class="math"><script type="math/tex">f \colon M \to N</script></span>.</li>
<li>If <span class="math"><script type="math/tex">\Delta \subseteq L_0</script></span>  and <span class="math"><script type="math/tex">\Delta</script></span> is closed under negation, then <span class="math"><script type="math/tex">\mathcal M \Rrightarrow_\Delta \mathcal N</script></span> implies <span class="math"><script type="math/tex">\mathcal M \equiv_\Delta \mathcal N</script></span>.</li>
</ol>
<hr>
<hr>
<h4>The Lemma on Constants</h4>
<p>Above we remarked that if <span class="math"><script type="math/tex">(\mathcal A, \mathbf a)</script></span> is an <span class="math"><script type="math/tex">L(\mathbf c)</script></span>-structure with <span class="math"><script type="math/tex">\mathcal A</script></span> an <span class="math"><script type="math/tex">L</script></span>-structure, then for every atomic formula <span class="math"><script type="math/tex">\varphi</script></span> of <span class="math"><script type="math/tex">L</script></span>, <span class="math"><script type="math/tex">\mathcal A \vDash \varphi(\mathbf a)</script></span> if and only if <span class="math"><script type="math/tex">(\mathcal A, \mathbf a) \vDash \varphi(\mathbf c)</script></span>.</p>
<p><strong>Lemma</strong> [2.3.2. Hodges] Let <span class="math"><script type="math/tex">L</script></span> be a language, <span class="math"><script type="math/tex">T</script></span> a theory in <span class="math"><script type="math/tex">L</script></span> and <span class="math"><script type="math/tex">\varphi(\mathbf x)</script></span> a formula in <span class="math"><script type="math/tex">L</script></span>. Let <span class="math"><script type="math/tex">\mathbf c</script></span> be a sequence of distinct constants that are not in <span class="math"><script type="math/tex">L</script></span>. Then <span class="math"><script type="math/tex">T \vdash \varphi(\mathbf c)</script></span> if and only if <span class="math"><script type="math/tex">T \vdash \forall \mathbf x\, \varphi</script></span>.</p>
<hr>
<h4>The Diagram Lemma</h4>
<p><strong>Lemma</strong> [6.1.2. Rothmaler] Let <span class="math"><script type="math/tex">\mathcal M</script></span> and <span class="math"><script type="math/tex">\mathcal N</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures.</p>
<ol>
<li>
<p><span class="math"><script type="math/tex">f \colon \mathcal M \hookrightarrow \mathcal N</script></span> <span class="math"><script type="math/tex">\; \Leftrightarrow \;</script></span>
<span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\mathbf{qf}}{\longrightarrow} \mathcal N</script></span>
<span class="math"><script type="math/tex">\; \Leftrightarrow \;</script></span> <span class="math"><script type="math/tex">(\mathcal N, f[M]) \vDash D(\mathcal M)</script></span>.<br>
In particular, <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N \; \Rightarrow \; f \colon \mathcal M \hookrightarrow \mathcal N</script></span>.</p>
</li>
<li>
<p><span class="math"><script type="math/tex">\mathcal M \hookrightarrow \mathcal N</script></span> <span class="math"><script type="math/tex">\; \Leftrightarrow \;</script></span> <span class="math"><script type="math/tex">\mathcal N</script></span> has an <span class="math"><script type="math/tex">L(M)</script></span>-expansion that models <span class="math"><script type="math/tex">D(\mathcal M)</script></span>.</p>
</li>
</ol>
<hr>
<h4>The Diagram Lemma (ver. 2)</h4>
<p>Let’s consider an alternative version of the Diagram Lemma that makes the role played by new constants more explicit. For this version, we will use the following additional notation:</p>
<ul>
<li><span class="math"><script type="math/tex">\mathbf c = (c_0, \dots, c_{n-1})=</script></span> an arbitrary tuple of distinct symbols not appearing in <span class="math"><script type="math/tex">L</script></span>;</li>
<li><span class="math"><script type="math/tex">\mathbf a = (a_0, \dots, a_{n-1}) \in M^n</script></span>, <span class="math"><script type="math/tex">\mathbf b = (b_0, \dots, b_{n-1}) \in N^n</script></span>;</li>
<li><span class="math"><script type="math/tex">(\mathcal M, \mathbf c)</script></span> and <span class="math"><script type="math/tex">(\mathcal N, \mathbf c)</script></span> are <span class="math"><script type="math/tex">L(\mathbf c)</script></span>-structures, where <span class="math"><script type="math/tex">c_i^{\mathcal M} = a_i</script></span> and <span class="math"><script type="math/tex">c_i^{\mathcal N} = b_i</script></span> are the interpretations in <span class="math"><script type="math/tex">\mathcal M</script></span> and <span class="math"><script type="math/tex">\mathcal N</script></span> of the new constant symbols;</li>
<li><span class="math"><script type="math/tex">\langle \mathbf a \rangle</script></span> is the substructure of <span class="math"><script type="math/tex">\mathcal M</script></span> generated by the elements of the tuple <span class="math"><script type="math/tex">\mathbf a</script></span>;</li>
<li><span class="math"><script type="math/tex">f[\mathbf a]:=(f(a_0), \dots, f(a_{n-1}))</script></span>.</li>
</ul>
<p><strong>Lemma</strong> [1.4.2. Hodges] The following are equivalent:</p>
<ol>
<li>For every atomic sentence <span class="math"><script type="math/tex">\varphi(\mathbf c)</script></span> of <span class="math"><script type="math/tex">L(\mathbf c)</script></span>, if
<span class="math"><script type="math/tex">(\mathcal M, \mathbf c) \vDash \varphi(\mathbf c)</script></span> then <span class="math"><script type="math/tex">(\mathcal N, \mathbf c) \vDash \varphi(\mathbf c)</script></span>.</li>
<li>There is a homomorphism <span class="math"><script type="math/tex">f \colon \langle \mathbf a \rangle \to \mathcal N</script></span> such that <span class="math"><script type="math/tex">f[\mathbf a] = \mathbf b</script></span>.</li>
<li>The homomorphism in 2 is unique, if it exists, and it is an embedding if and only if:<br>
for every atomic sentence <span class="math"><script type="math/tex">\varphi</script></span> of <span class="math"><script type="math/tex">L(\mathbf c)</script></span>, we have
<span class="math"><script type="math/tex">(\mathcal M, \mathbf c) \vDash \varphi \; \Leftrightarrow \; (\mathcal N, \mathbf c) \vDash \varphi</script></span>.</li>
</ol>
<hr>
<hr>
<h3>Elementary equivalence</h3>
<h4>Isomorphic structures are elementarily equivalent</h4>
<p><strong>Proposition</strong> [6.1.3. Rothmaler]
If <span class="math"><script type="math/tex">f \colon \mathcal M \cong \mathcal N</script></span>, then <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>, hence also <span class="math"><script type="math/tex">\mathcal M \equiv \mathcal N</script></span>.</p>
<p>Proof of the first implication is on page 70 of the text.</p>
<p>The second implication is <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span> implies <span class="math"><script type="math/tex">\mathcal M \equiv \mathcal N</script></span>.  That’s true because, if <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>, then we have not only <span class="math"><script type="math/tex">\varphi \in \operatorname{Th} \mathcal M</script></span> implies <span class="math"><script type="math/tex">\varphi \in \operatorname{Th}\mathcal N</script></span>,
but also <span class="math"><script type="math/tex">\neg \varphi \in \operatorname{Th} \mathcal M</script></span> implies <span class="math"><script type="math/tex">\neg \varphi \in \operatorname{Th}\mathcal N</script></span>.
From the former, <span class="math"><script type="math/tex">\mathcal M \Rrightarrow \mathcal N</script></span>.  From the latter,
<span class="math"><script type="math/tex">\mathcal M \Lleftarrow \mathcal N</script></span>.  Thus, <span class="math"><script type="math/tex">\mathcal M \equiv \mathcal N</script></span>.</p>
<hr>
<p>The converse of 6.1.3 holds if and only if the structures involved are finite, as the next proposition shows.</p>
<p><strong>Proposition</strong> [8.1.1. Rothmaler] Let <span class="math"><script type="math/tex">\mathcal M</script></span> be an <span class="math"><script type="math/tex">L</script></span>-structure. The following are equivalent:</p>
<ol>
<li><span class="math"><script type="math/tex">\mathcal N \equiv \mathcal M</script></span> implies <span class="math"><script type="math/tex">\mathcal N \cong \mathcal M</script></span> for any <span class="math"><script type="math/tex">L</script></span>-structure <span class="math"><script type="math/tex">\mathcal N</script></span>.</li>
<li><span class="math"><script type="math/tex">\mathcal M</script></span> is finite.</li>
</ol>
<hr>
<h4>All models of a complete theory are elementarily equivalent</h4>
<p><strong>Proposition</strong> [8.1.2. Rothmaler] A theory is complete iff its models are elementarily equivalent.</p>
<p><strong>Corollary</strong> [8.1.3. Rothmaler] A complete theory has a finite model iff it has only one model (up to isomorphism).</p>
<hr>
<hr>
<h3>Elementary maps</h3>
<p>Let <span class="math"><script type="math/tex">\mathcal M</script></span> and <span class="math"><script type="math/tex">\mathcal N</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures. A map <span class="math"><script type="math/tex">f \colon M \to N</script></span> is called <strong>elementary</strong> if <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>.  The structure <span class="math"><script type="math/tex">\mathcal M</script></span> is <strong>elementarily embeddable</strong> in <span class="math"><script type="math/tex">\mathcal N</script></span>, in symbols <span class="math"><script type="math/tex">\mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>, if there is an elementary map <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>.</p>
<p><strong>Remarks.</strong></p>
<ol>
<li>If <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>, then <span class="math"><script type="math/tex">\mathcal M \equiv \mathcal N</script></span>.</li>
<li>While elementary equivalence is weaker than isomorphism, every elementary map is automatically an isomorphic embedding (by Lemma 6.1.2(1)). Therefore elementary maps are also called <strong>elementary embeddings</strong>, and the notation <span class="math"><script type="math/tex">f \colon \mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span> is justified.</li>
<li>The converse is not true in general, unless the embedding is surjective
(i.e., an isomorphism), since</li>
<li>Proposition 6.1.3 says that every isomorphism <span class="math"><script type="math/tex">f \colon \mathcal M \cong \mathcal N</script></span> is an elementary map.</li>
</ol>
<hr>
<h4>Elementary Diagram Lemma</h4>
<p>The <strong>elementary diagram</strong> of an <span class="math"><script type="math/tex">L</script></span>-structure <span class="math"><script type="math/tex">\mathcal M</script></span> is the complete <span class="math"><script type="math/tex">L(M)</script></span>-theory <span class="math"><script type="math/tex">\operatorname{Th}(\mathcal M, M)</script></span>.</p>
<p><strong>Lemma</strong> [8.2.1. Rothmaler] Let <span class="math"><script type="math/tex">\mathcal M</script></span> and <span class="math"><script type="math/tex">\mathcal N</script></span> be <span class="math"><script type="math/tex">L</script></span>-structures and <span class="math"><script type="math/tex">f \colon M \rightarrow N</script></span>.</p>
<ol>
<li><span class="math"><script type="math/tex">f</script></span> is elementary <span class="math"><script type="math/tex">\; \Leftrightarrow \;</script></span>  <span class="math"><script type="math/tex">(\mathcal M, M) \equiv (\mathcal N, f[M])</script></span> <span class="math"><script type="math/tex">\; \Leftrightarrow \;</script></span>
<span class="math"><script type="math/tex">(\mathcal N, f[M]) \vDash Th(\mathcal M, M)</script></span>.</li>
<li><span class="math"><script type="math/tex">\mathcal M \stackrel{\equiv}{\hookrightarrow} \mathcal N</script></span>
<span class="math"><script type="math/tex">\; \Leftrightarrow \;</script></span> iff
<span class="math"><script type="math/tex">\mathcal N</script></span> has an expansion that is a model of <span class="math"><script type="math/tex">\operatorname{Th}(\mathcal M, M)</script></span>.</li>
</ol></body>
</html>
